# TASK-022: Test cursor-runner HTTP failure in processNextTask

**Section**: 2. TaskOperatorService Unit Tests
**Subsection**: 2.7
**Task ID**: TASK-022

## Description

Add a test case for the `processNextTask` method to verify it correctly handles the case where the async iterate call to cursor-runner fails (returns non-OK HTTP status). The test should verify that the pending task is removed, task status is reset to ready, and the lock is released.

**Reference Implementation**: 
- `virtual-assistant/cursor-agents/src/services/task-operator-service.ts` - `processNextTask()` method with async iterate error handling

## Current State

The `processNextTask` method:
- Creates conversation successfully
- Calls async iterate endpoint (`/cursor/iterate/async`)
- If async iterate returns non-OK status, removes pending task entry
- Resets task status to ready
- Releases the lock
- Returns error result

The test file `tests/services/task-operator-service.test.ts` exists with previous tests.

**Important**: This task should be executed after TASK-021.

## Checklist

### Preparation and Setup

- [ ] Review `processNextTask` async iterate error handling
- [ ] Understand how pending tasks are removed on error
- [ ] Review HTTP error status handling
- [ ] Understand lock release on async iterate failure

### Implementation Steps

- [ ] Step 1: Set up mocks for async iterate failure
  - [ ] Mock Redis `set` to return `'OK'` (lock acquired)
  - [ ] Mock `DatabaseService.getNextReadyTask` to return sample task
  - [ ] Mock `DatabaseService.updateTaskStatus` for both IN_PROGRESS and reset to ready
  - [ ] Mock `fetch` for conversation creation to succeed
  - [ ] Mock `fetch` for async iterate to return non-OK status (e.g., 500)
- [ ] Step 2: Write test for async iterate failure
  - [ ] Create test: `it('should remove pending task and reset status when async iterate fails', async () => { ... })`
  - [ ] Arrange: 
    - [ ] Sample task with `id=1`
    - [ ] Mock conversation creation to succeed
    - [ ] Mock async iterate to return 500 or other error status
    - [ ] Track pending task entry creation
  - [ ] Act: Call `processNextTask()`
  - [ ] Assert: 
    - [ ] Result has `processed: false` and `reason: 'error'`
    - [ ] Pending task entry was created then removed
    - [ ] Task status was reset to ready
    - [ ] Lock was released

### Specific Requirements

- [ ] Requirement 1: Test must verify error handling
  - Acceptance: Method handles async iterate failure correctly
- [ ] Requirement 2: Test must verify pending task cleanup
  - Acceptance: Pending task entry is removed on error
- [ ] Requirement 3: Test must verify task status reset
  - Acceptance: Task status is reset to ready after failure
- [ ] Requirement 4: Test must verify lock release
  - Acceptance: Lock is released when async iterate fails

### Error Handling and Edge Cases

- [ ] Handle different HTTP error statuses (500, 503, etc.)
- [ ] Verify pending task is removed even if status update fails
- [ ] Test that no callback will be processed for this requestId
- [ ] Verify error is logged

### Testing

- [ ] Run `npm run test:unit` to verify test executes
- [ ] Verify test passes consistently
- [ ] Verify all mocks are called correctly
- [ ] Run full test suite to ensure no regressions
- [ ] **DO NOT manually test by running the server** - use automated tests only

### Documentation

- [ ] Add comments explaining async iterate failure scenario
- [ ] Document why pending task is removed
- [ ] Note HTTP error status handling

### Verification

- [ ] Verify test passes consistently
- [ ] Verify error handling works correctly
- [ ] Verify pending task cleanup works
- [ ] Confirm test follows project conventions

## Notes

- This task is part of **Phase 2 â€“ TaskOperatorService Unit Tests**
- **Execution Timing**: Should be executed after TASK-021
- **Dependencies**: 
  - TASK-016: Create a new test file for TaskOperatorService
  - TASK-021: Test conversation creation failure
- **Important Considerations**: 
  - Async iterate failure occurs after conversation is created
  - Pending task must be cleaned up to prevent orphaned entries
  - Task status reset allows retry later
  - Lock release allows other instances to process
- **Task Independence**: Can be completed independently after TASK-021
- **Current State**: Test file exists with previous error handling tests

## Related Tasks

- Previous: TASK-021 (Test conversation creation failure)
- Next: TASK-023 (Test handleCallback for unknown requestId)
- Dependencies:
  - TASK-016: Create a new test file for TaskOperatorService
  - TASK-021: Test conversation creation failure
- Related:
  - TASK-020: Tested happy path
  - TASK-021: Tested conversation creation failure
  - TASK-024: Will test callback success

## Definition of Done

### Task Type: TESTING TASK

**Description**: This task involves writing a test case for `processNextTask` when async iterate HTTP call fails.

**Definition of Done**: "A test case is written that verifies `processNextTask` correctly handles async iterate HTTP failure by removing pending task entry, resetting task status to ready, and releasing the lock. The test passes consistently. All changes have been committed to git and pushed to origin."

### User Stories

1. **As a developer**, I want to verify HTTP error handling works so that the system recovers from cursor-runner failures.
   - **Acceptance Criteria**: 
     - Test verifies method handles async iterate HTTP errors
     - Test verifies pending task is removed
     - Test verifies task status is reset

2. **As a developer**, I want to verify cleanup works so that orphaned pending tasks don't accumulate.
   - **Acceptance Criteria**:
     - Test verifies pending task entry is removed on error
     - Test verifies lock is released

### Automated Tests

The test case should be:

```typescript
it('should remove pending task and reset status when async iterate fails', async () => {
  // Arrange: Mock async iterate to fail
  const sampleTask = { id: 1, prompt: 'test', order: 0, uuid: 'test-uuid', status: 0 };
  const mockRedis = { set: jest.fn().mockResolvedValue('OK'), del: jest.fn().mockResolvedValue(1) };
  const mockDbService = {
    getNextReadyTask: jest.fn().mockReturnValue(sampleTask),
    updateTaskStatus: jest.fn().mockReturnValue(true),
  };
  global.fetch = jest.fn()
    .mockResolvedValueOnce({ // Conversation creation succeeds
      ok: true,
      text: () => Promise.resolve(JSON.stringify({ conversationId: 'conv-123' })),
    })
    .mockResolvedValueOnce({ // Async iterate fails
      ok: false,
      status: 500,
      statusText: 'Internal Server Error',
    });
  
  const service = TaskOperatorService.getInstance(mockRedis);
  // Inject mocks
  
  // Act
  const result = await service.processNextTask();
  
  // Assert
  expect(result).toEqual({ processed: false, reason: 'error' });
  // Verify pending task was removed
  // Verify task status reset to ready
  // Verify lock released
});
```

- [ ] Test case written and passes
- [ ] Test verifies async iterate failure handling
- [ ] Test verifies pending task cleanup
- [ ] Test verifies task status reset

### Git Commit and Push Requirements

- [ ] Test case added to `tests/services/task-operator-service.test.ts`
- [ ] Commit message follows project conventions (e.g., "test: add processNextTask async iterate failure test")
- [ ] Changes are pushed to origin
- [ ] Commit includes only the test case addition

### Final Checklist

- [ ] Test case written and passes
- [ ] Test verifies error handling
- [ ] Test verifies pending task cleanup
- [ ] Test verifies task status reset
- [ ] All changes committed to git
- [ ] Code pushed to origin
- [ ] Task marked as complete
