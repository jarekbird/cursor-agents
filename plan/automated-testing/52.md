# TASK-052: Add failure-injection integration tests

**Section**: 7. Integration & E2E-lite Scenarios
**Subsection**: 7.3
**Task ID**: TASK-052

## Description

Add integration tests that inject failures to verify system resilience. The tests should simulate Redis being down (BullMQ operations rejecting) and verify that HTTP endpoints return 500 errors but the app continues to respond to other requests. Also verify MCP handlers fail gracefully with `isError: true` responses.

**Reference Implementation**: 
- `virtual-assistant/cursor-agents/src/app.ts` - HTTP endpoints with error handling
- `virtual-assistant/cursor-agents/src/mcp/server.ts` - MCP handlers with error handling
- `virtual-assistant/cursor-agents/tests/integration.test.ts` - existing test structure

## Current State

The application should handle failures gracefully:
- HTTP endpoints should return 500 JSON errors when underlying operations fail
- App instance should continue running and respond to other requests
- MCP handlers should return `isError: true` responses without crashing

The test file `tests/integration.test.ts` exists but may not have failure-injection tests.

**Important**: This task should be executed after TASK-051.

## Checklist

### Preparation and Setup

- [ ] Review error handling in HTTP endpoints
- [ ] Review error handling in MCP handlers
- [ ] Understand how to simulate Redis failures
- [ ] Review existing `integration.test.ts` structure

### Implementation Steps

- [ ] Step 1: Write test for Redis failure in HTTP endpoints
  - [ ] Create test: `it('should return 500 errors when Redis is down but app continues', async () => { ... })`
    - [ ] Arrange: 
      - [ ] Create app instance
      - [ ] Make QueueManager operations reject (simulate Redis down)
    - [ ] Act: 
      - [ ] Make request to endpoint that uses QueueManager (e.g., POST `/agents`)
      - [ ] Make request to endpoint that doesn't use QueueManager (e.g., GET `/health`)
    - [ ] Assert: 
      - [ ] First request returns 500 with error JSON
      - [ ] Second request succeeds (app still responsive)
      - [ ] App instance is still running
- [ ] Step 2: Write test for MCP handler failures
  - [ ] Create test: `it('should return isError: true when MCP handler fails', async () => { ... })`
    - [ ] Arrange: 
      - [ ] Make QueueManager operations reject
      - [ ] Set up MCP tool handler
    - [ ] Act: Call MCP tool (e.g., `list_agents`)
    - [ ] Assert: 
      - [ ] Response has `isError: true`
      - [ ] Error message is present
      - [ ] Process doesn't crash

### Specific Requirements

- [ ] Requirement 1: Test must verify HTTP error handling
  - Acceptance: 500 errors returned, app continues running
- [ ] Requirement 2: Test must verify app resilience
  - Acceptance: App responds to other requests after failure
- [ ] Requirement 3: Test must verify MCP error handling
  - Acceptance: MCP handlers return isError: true, don't crash
- [ ] Requirement 4: Test must simulate realistic failures
  - Acceptance: Failures are realistic (Redis down, etc.)

### Error Handling and Edge Cases

- [ ] Handle case where multiple endpoints fail
- [ ] Verify error messages are descriptive
- [ ] Test with various failure types
- [ ] Verify process doesn't exit

### Testing

- [ ] Run `npm run test:http` or `npm run test:unit` to verify tests execute
- [ ] Verify all test cases pass
- [ ] Verify existing tests still pass
- [ ] Run full test suite to ensure no regressions
- [ ] **DO NOT manually test by running the server** - use automated tests only

### Documentation

- [ ] Add comments explaining failure-injection approach
- [ ] Document why resilience is important
- [ ] Note error handling patterns

### Verification

- [ ] Verify all test cases pass consistently
- [ ] Verify error handling works
- [ ] Verify app resilience works
- [ ] Confirm tests follow project conventions

## Notes

- This task is part of **Phase 7 â€“ Integration & E2E-lite Scenarios**
- **Execution Timing**: Should be executed after TASK-051
- **Dependencies**: 
  - TASK-051: Add task-operator lifecycle integration test
- **Important Considerations**: 
  - Failure-injection tests verify system resilience
  - App should continue running after failures
  - Error responses should be user-friendly
  - MCP handlers should fail gracefully
  - These tests ensure production reliability
- **Task Independence**: Can be completed independently after TASK-051
- **Current State**: Test file exists but may not have failure-injection tests

## Related Tasks

- Previous: TASK-051 (Add task-operator lifecycle integration test)
- Next: TASK-053 (Add E2E-lite entrypoint tests)
- Dependencies:
  - TASK-051: Add task-operator lifecycle integration test
- Related:
  - TASK-053: Will test entrypoint behavior

## Definition of Done

### Task Type: TESTING TASK

**Description**: This task involves adding failure-injection integration tests to verify system resilience.

**Definition of Done**: "Failure-injection integration tests are added that verify HTTP endpoints return 500 errors when Redis is down but app continues responding, and MCP handlers return isError: true without crashing. All tests pass consistently. All changes have been committed to git and pushed to origin."

### User Stories

1. **As a developer**, I want to verify system resilience works so that failures don't crash the application.
   - **Acceptance Criteria**: 
     - Test verifies app continues running after failures
     - Test verifies other requests still work
     - Test passes consistently

2. **As a developer**, I want to verify error handling works so that users see helpful error messages.
   - **Acceptance Criteria**:
     - Test verifies 500 errors are returned
     - Test verifies MCP handlers return isError: true
     - Test verifies error messages are descriptive

### Automated Tests

Test cases should include:

```typescript
describe('Failure-injection integration', () => {
  it('should return 500 errors when Redis is down but app continues', async () => {
    // Arrange: App with QueueManager that rejects
    const app = new CursorAgentsApp();
    mockQueueManager.addOneTimeAgent.mockRejectedValue(new Error('Redis connection failed'));
    
    // Act: Request that uses QueueManager
    const errorResponse = await request(app.getApp())
      .post('/agents')
      .send({ name: 'test', targetUrl: 'http://example.com', oneTime: true })
      .expect(500);
    expect(errorResponse.body).toHaveProperty('error');
    
    // Act: Request that doesn't use QueueManager
    const healthResponse = await request(app.getApp())
      .get('/health')
      .expect(200);
    expect(healthResponse.body).toHaveProperty('status', 'ok');
  });
  
  it('should return isError: true when MCP handler fails', async () => {
    // Arrange: QueueManager rejects
    // Act: Call MCP tool
    // Assert: Response has isError: true, error message
  });
});
```

- [ ] All test cases written and pass
- [ ] Tests verify HTTP error handling
- [ ] Tests verify app resilience
- [ ] Tests verify MCP error handling

### Git Commit and Push Requirements

- [ ] Test cases added to `tests/integration.test.ts`
- [ ] Commit message follows project conventions (e.g., "test: add failure-injection integration tests")
- [ ] Changes are pushed to origin
- [ ] Commit includes only the test case additions

### Final Checklist

- [ ] All test cases written and pass
- [ ] Tests verify error handling
- [ ] Tests verify app resilience
- [ ] All changes committed to git
- [ ] Code pushed to origin
- [ ] Task marked as complete
