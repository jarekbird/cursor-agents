name: Deploy cursor-agents

on:
  push:
    branches:
      - master
      - main
  workflow_dispatch:  # Allows manual trigger from GitHub UI

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        env:
          DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          timeout: 120s
          command_timeout: 15m
          script: |
            set -e
            
            # Initialize Docker resources (network and volumes) if they don't exist
            echo "Initializing Docker resources..."
            
            # Create network if it doesn't exist
            if ! docker network ls | grep -q "virtual-assistant-network"; then
              echo "Creating virtual-assistant-network..."
              docker network create virtual-assistant-network || true
            fi
            
            # Create shared SQLite database volume if it doesn't exist
            if ! docker volume inspect shared_sqlite_db >/dev/null 2>&1; then
              echo "Creating shared_sqlite_db volume..."
              docker volume create shared_sqlite_db || true
            fi
            
            # Create shared Redis data volume if it doesn't exist
            if ! docker volume inspect shared_redis_data >/dev/null 2>&1; then
              echo "Creating shared_redis_data volume..."
              docker volume create shared_redis_data || true
            fi
            
            # Create cursor_runner_repositories volume if it doesn't exist
            if ! docker volume inspect cursor_runner_repositories >/dev/null 2>&1; then
              echo "Creating cursor_runner_repositories volume..."
              docker volume create cursor_runner_repositories || true
            fi
            
            # Navigate to the service directory in the monorepo
            # Best Practice: Each service deploys independently using its own docker-compose.yml
            # The shared docker-compose.yml is for local development only
            SERVICE_DIR=""
            
            if [ -d "VirtualAssistant/cursor-agents" ] && [ -f "VirtualAssistant/cursor-agents/docker-compose.yml" ]; then
              # Monorepo structure - navigate to service directory
              echo "✓ Detected monorepo structure - navigating to VirtualAssistant/cursor-agents/"
              SERVICE_DIR="VirtualAssistant/cursor-agents"
              cd VirtualAssistant/cursor-agents
            elif [ -d "$HOME/VirtualAssistant/cursor-agents" ] && [ -f "$HOME/VirtualAssistant/cursor-agents/docker-compose.yml" ]; then
              echo "✓ Detected monorepo structure at $HOME/VirtualAssistant/cursor-agents/"
              SERVICE_DIR="$HOME/VirtualAssistant/cursor-agents"
              cd $HOME/VirtualAssistant/cursor-agents
            elif [ -d "/opt/VirtualAssistant/cursor-agents" ] && [ -f "/opt/VirtualAssistant/cursor-agents/docker-compose.yml" ]; then
              echo "✓ Detected monorepo structure at /opt/VirtualAssistant/cursor-agents/"
              SERVICE_DIR="/opt/VirtualAssistant/cursor-agents"
              cd /opt/VirtualAssistant/cursor-agents
            elif [ -d "cursor-agents" ] && [ -f "cursor-agents/docker-compose.yml" ]; then
              # Standalone structure (fallback)
              echo "✓ Detected standalone structure - navigating to cursor-agents/"
              SERVICE_DIR="cursor-agents"
              cd cursor-agents
            elif [ -d "$HOME/cursor-agents" ] && [ -f "$HOME/cursor-agents/docker-compose.yml" ]; then
              echo "✓ Detected standalone structure at $HOME/cursor-agents/"
              SERVICE_DIR="$HOME/cursor-agents"
              cd $HOME/cursor-agents
            elif [ -d "/opt/cursor-agents" ] && [ -f "/opt/cursor-agents/docker-compose.yml" ]; then
              echo "✓ Detected standalone structure at /opt/cursor-agents/"
              SERVICE_DIR="/opt/cursor-agents"
              cd /opt/cursor-agents
            else
              echo "Error: Could not find cursor-agents service directory with docker-compose.yml"
              echo "Tried locations:"
              echo "  - VirtualAssistant/cursor-agents/docker-compose.yml (monorepo)"
              echo "  - $HOME/VirtualAssistant/cursor-agents/docker-compose.yml"
              echo "  - /opt/VirtualAssistant/cursor-agents/docker-compose.yml"
              echo "  - cursor-agents/docker-compose.yml (standalone)"
              echo "  - $HOME/cursor-agents/docker-compose.yml"
              echo "  - /opt/cursor-agents/docker-compose.yml"
              echo ""
              echo "Current directory: $(pwd)"
              echo "Directory contents:"
              ls -la
              exit 1
            fi
            
            # Store absolute path of service directory for later
            SERVICE_DIR_ABS=$(pwd)
            echo "Service directory: $SERVICE_DIR_ABS"
            echo "Using service's individual docker-compose.yml (best practice for independent deployment)"
            
            # Update code from git
            # In a monorepo, git operations work from any subdirectory
            # Git will automatically find the repository root
            echo "Updating code from git..."
            GIT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || echo "")
            if [ -z "$GIT_ROOT" ]; then
              echo "Error: Not in a git repository"
              exit 1
            fi
            echo "Git repository root: $GIT_ROOT"
            cd "$GIT_ROOT"
            git fetch origin || { echo "Git fetch failed"; exit 1; }
            BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || echo "main")
            git reset --hard origin/$BRANCH || { echo "Git reset failed"; exit 1; }
            # Navigate back to service directory
            cd "$SERVICE_DIR_ABS"
            echo "Back in service directory: $(pwd)"
            
            # DOMAIN_NAME is optional - used for Traefik routing labels
            # Should be just the domain name (e.g., "jarekva.com") without protocol
            # Can be set via GitHub secret DOMAIN_NAME or environment variable
            export DOMAIN_NAME=${DOMAIN_NAME:-jarekva.com}
            echo "Using DOMAIN_NAME: $DOMAIN_NAME"
            
            # Verify docker-compose.yml exists
            if [ ! -f "docker-compose.yml" ]; then
              echo "Error: docker-compose.yml not found in current directory: $(pwd)"
              ls -la
              exit 1
            fi
            echo "✓ docker-compose.yml found"
            
            # Build and deploy
            # Use docker-compose (with hyphen) for compatibility, or docker compose (with space) if available
            echo "Detecting docker compose command..."
            COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1; then
              COMPOSE_CMD="docker-compose"
              echo "Using docker-compose (legacy)"
            elif docker compose version >/dev/null 2>&1; then
              COMPOSE_CMD="docker compose"
              echo "Using docker compose (new)"
            else
              echo "Error: Neither docker-compose nor docker compose found"
              exit 1
            fi
            
            # Verify docker compose works
            echo "Verifying docker compose command..."
            if ! $COMPOSE_CMD version >/dev/null 2>&1; then
              echo "Error: docker compose command not working"
              $COMPOSE_CMD version || true
              exit 1
            fi
            echo "Docker compose command verified"
            
            # Verify external volumes and network exist before building
            echo "Verifying external Docker resources..."
            if ! docker volume inspect cursor_runner_repositories >/dev/null 2>&1; then
              echo "Error: cursor_runner_repositories volume does not exist"
              echo "Creating volume..."
              docker volume create cursor_runner_repositories || exit 1
            fi
            if ! docker volume inspect shared_sqlite_db >/dev/null 2>&1; then
              echo "Error: shared_sqlite_db volume does not exist"
              echo "Creating volume..."
              docker volume create shared_sqlite_db || exit 1
            fi
            if ! docker network inspect virtual-assistant-network >/dev/null 2>&1; then
              echo "Error: virtual-assistant-network does not exist"
              echo "Creating network..."
              docker network create virtual-assistant-network || exit 1
            fi
            echo "External Docker resources verified"
            
            echo "Building Docker container..."
            # Export DOMAIN_NAME for docker compose (needed for label validation)
            export DOMAIN_NAME
            set +e  # Temporarily disable exit on error to capture full output
            BUILD_OUTPUT=$(DOMAIN_NAME=$DOMAIN_NAME $COMPOSE_CMD build cursor-agents 2>&1)
            BUILD_EXIT=$?
            set -e  # Re-enable exit on error
            
            if [ $BUILD_EXIT -ne 0 ]; then
              echo "Docker build failed with exit code: $BUILD_EXIT"
              echo "Docker build output:"
              echo "$BUILD_OUTPUT"
              exit 1
            fi
            echo "Docker build completed successfully"
            
            echo "Starting Docker container..."
            # Force recreate container to ensure entrypoint script runs and copies new tools
            # Export DOMAIN_NAME in the environment for docker compose to use in labels
            set +e  # Temporarily disable exit on error to capture full output
            UP_OUTPUT=$(DOMAIN_NAME=$DOMAIN_NAME $COMPOSE_CMD up -d --force-recreate --no-deps cursor-agents 2>&1)
            UP_EXIT=$?
            set -e  # Re-enable exit on error
            
            if [ $UP_EXIT -ne 0 ]; then
              echo "Docker up failed with exit code: $UP_EXIT"
              echo "Docker up output:"
              echo "$UP_OUTPUT"
              exit 1
            fi
            echo "Docker container started successfully"
            echo "Deployment completed successfully"
          script_stop: true
          debug: true

